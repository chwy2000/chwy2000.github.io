<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Detección de Fraudes Red Neuronal Convolucional de una dimensión con TensorFlow.js.</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.18.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.2/papaparse.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);
            color: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        h1 {
            margin: 0;
            font-size: 2.5rem;
        }
        
        .description {
            font-size: 1.1rem;
            margin-top: 10px;
        }
        
        .container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .panel {
            flex: 1;
            min-width: 300px;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .panel h2 {
            color: #2575fc;
            margin-top: 0;
            border-bottom: 2px solid #f0f0f0;
            padding-bottom: 10px;
        }
        
        .file-upload {
            border: 2px dashed #6a11cb;
            padding: 20px;
            text-align: center;
            border-radius: 8px;
            margin-bottom: 20px;
            background-color: #f9f9f9;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .file-upload:hover {
            background-color: #f0f0f0;
            border-color: #2575fc;
        }
        
        .file-upload p {
            margin: 0;
            color: #666;
        }
        
        .file-upload.active {
            background-color: #e6f7ff;
            border-color: #1890ff;
        }
        
        button {
            background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
            margin: 10px 0;
            width: 100%;
            transition: all 0.3s;
        }
        
        button:hover {
            opacity: 0.9;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        
        button:disabled {
            background: #cccccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .results {
            margin-top: 20px;
        }
        
        .result-item {
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 5px;
            background-color: #f9f9f9;
            border-left: 4px solid #6a11cb;
        }
        
        .result-item.fraud {
            border-left-color: #ff4d4f;
            background-color: #fff2f0;
        }
        
        .result-item.legit {
            border-left-color: #52c41a;
            background-color: #f6ffed;
        }
        
        .progress {
            height: 20px;
            background-color: #f0f0f0;
            border-radius: 10px;
            margin-bottom: 20px;
            overflow: hidden;
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);
            border-radius: 10px;
            width: 0%;
            transition: width 0.3s;
        }
        
        .stats {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }
        
        .stat-box {
            text-align: center;
            padding: 15px;
            border-radius: 8px;
            background-color: #f0f8ff;
            flex: 1;
            margin: 0 5px;
        }
        
        .stat-box h3 {
            margin: 0;
            color: #2575fc;
        }
        
        .stat-box p {
            font-size: 1.5rem;
            margin: 10px 0 0;
            font-weight: bold;
        }
        
        #trainingLog {
            height: 200px;
            overflow-y: auto;
            background-color: #f9f9f9;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 0.9rem;
        }
        
        .log-entry {
            margin-bottom: 5px;
            padding: 5px;
            border-bottom: 1px solid #eee;
        }
        
        .model-architecture {
            margin-top: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 8px;
            font-family: monospace;
            white-space: pre-wrap;
        }
        
        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }
            
            .stats {
                flex-direction: column;
            }
            
            .stat-box {
                margin: 5px 0;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Detección de Fraudes Red Neuronal Convolucional de una dimensión con TensorFlow.js.</h1>
        <p class="description">Instrucciones: Primero cargue el archivo .CSV con el formato requerido, después seleccione el botón "Entrenar Modelo", una vez finalizado el entrenamiento seleccione el botón "Predecir Fradues"</p>
    </header>
    
    <div class="container">
        <div class="panel">
            <h2>Cargar Datos</h2>
            <div class="file-upload" id="fileUpload">
                <p>Haga clic aquí o arrastre un archivo CSV</p>
                <input type="file" id="csvFile" accept=".csv" style="display: none;">
            </div>
            <button id="trainBtn" disabled>Entrenar Modelo</button>
            <button id="predictBtn" disabled>Predecir Fraudes</button>
            
            <div class="progress">
                <div class="progress-bar" id="progressBar"></div>
            </div>
            
            <div class="stats">
                <div class="stat-box">
                    <h3>Registros</h3>
                    <p id="recordsCount">0</p>
                </div>
                <div class="stat-box">
                    <h3>Características</h3>
                    <p id="featuresCount">0</p>
                </div>
                <div class="stat-box">
                    <h3>Precisión</h3>
                    <p id="accuracy">0%</p>
                </div>
        
        <div class="panel">
            <h2>Resultados</h2>
            <div id="resultsContainer" class="results">
                <p>Los resultados aparecerán aquí después de ejecutar la predicción.</p>
            </div>
        </div>
    </div>
    
    <div class="panel">
        <h2>Registro de Entrenamiento</h2>
        <div id="trainingLog"></div>
    </div>

    <script>
        // Variables globales
        let model;
        let trainingData = {};
        let parsedData = [];
        let featureColumns = [];
        
        // Elementos DOM
        const fileUpload = document.getElementById('fileUpload');
        const csvFile = document.getElementById('csvFile');
        const trainBtn = document.getElementById('trainBtn');
        const predictBtn = document.getElementById('predictBtn');
        const progressBar = document.getElementById('progressBar');
        const recordsCount = document.getElementById('recordsCount');
        const featuresCount = document.getElementById('featuresCount');
        const accuracy = document.getElementById('accuracy');
        const resultsContainer = document.getElementById('resultsContainer');
        const trainingLog = document.getElementById('trainingLog');
        
        // Event Listeners
        fileUpload.addEventListener('click', () => csvFile.click());
        fileUpload.addEventListener('dragover', handleDragOver);
        fileUpload.addEventListener('drop', handleDrop);
        csvFile.addEventListener('change', handleFileSelect);
        trainBtn.addEventListener('click', trainModel);
        predictBtn.addEventListener('click', predictFrauds);
        
        // Funciones para manejar archivos
        function handleDragOver(e) {
            e.preventDefault();
            e.stopPropagation();
            fileUpload.classList.add('active');
        }
        
        function handleDrop(e) {
            e.preventDefault();
            e.stopPropagation();
            fileUpload.classList.remove('active');
            
            if (e.dataTransfer.files.length) {
                processCSVFile(e.dataTransfer.files[0]);
            }
        }
        
        function handleFileSelect(e) {
            if (e.target.files.length) {
                processCSVFile(e.target.files[0]);
            }
        }
        
        function processCSVFile(file) {
            addLog('Procesando archivo: ' + file.name);
            
            Papa.parse(file, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true,
                complete: function(results) {
                    if (results.data.length === 0) {
                        addLog('Error: El archivo CSV está vacío o no tiene datos válidos.');
                        return;
                    }
                    
                    parsedData = results.data;
                    recordsCount.textContent = parsedData.length;
                    
                    // Identificar columnas de características (excluyendo la columna Actor y Type)
                    const firstRow = parsedData[0];
                    featureColumns = Object.keys(firstRow).filter(key => 
                        key !== 'Actor' && key !== 'Type' && key !== 'A_Acc' && typeof firstRow[key] === 'number'
                    );
                    
                    featuresCount.textContent = featureColumns.length;
                    
                    addLog(`Datos cargados: ${parsedData.length} registros con ${featureColumns.length} características.`);
                    addLog(`Características: ${featureColumns.join(', ')}`);
                    
                    // Preparar datos para entrenamiento
                    prepareTrainingData();
                    trainBtn.disabled = false;
                },
                error: function(error) {
                    addLog('Error al procesar el archivo CSV: ' + error);
                }
            });
        }
        
        function prepareTrainingData() {
            // Separar características y etiquetas
            const features = [];
            const labels = [];
            
            parsedData.forEach(row => {
                // Obtener valores de características en el orden correcto
                const featureValues = featureColumns.map(col => row[col]);
                features.push(featureValues);
                
                // Convertir la etiqueta a numérica (Bot -> 1, Human -> 0)
                labels.push(row.Type === 'Bot' ? 1 : 0);
            });
            
            trainingData = {
                features: features,
                labels: labels,
                inputShape: [featureColumns.length, 1]  // Forma para CNN 1D: [longitud_secuencia, canales]
            };
            
            addLog('Datos preparados para entrenamiento con CNN 1D.');
            addLog(`Forma de entrada: [${trainingData.inputShape[0]}, ${trainingData.inputShape[1]}]`);
        }
        
        function createModel() {
            const model = tf.sequential();
            
            // Capa de entrada - remodelar para CNN 1D
            model.add(tf.layers.inputLayer({
                inputShape: trainingData.inputShape
            }));
            
            // Primera capa convolucional 1D
            model.add(tf.layers.conv1d({
                filters: 64,
                kernelSize: 3,
                activation: 'relu',
                padding: 'same'
            }));
            
            // Capa de agrupación máxima
            model.add(tf.layers.maxPooling1d({
                poolSize: 2,
                padding: 'same'
            }));
            
            // Segunda capa convolucional 1D
            model.add(tf.layers.conv1d({
                filters: 32,
                kernelSize: 3,
                activation: 'relu',
                padding: 'same'
            }));
            
            // Agrupación global para convertir la salida 3D en 2D
            model.add(tf.layers.globalAveragePooling1d());
            
            // Capa completamente conectada
            model.add(tf.layers.dense({
                units: 16,
                activation: 'relu'
            }));
            
            // Capa de salida (clasificación binaria)
            model.add(tf.layers.dense({
                units: 1,
                activation: 'sigmoid'
            }));
            
            // Compilar el modelo
            model.compile({
                optimizer: tf.train.adam(0.001),
                loss: 'binaryCrossentropy',
                metrics: ['accuracy']
            });
            
            return model;
        }
        
        async function trainModel() {
            trainBtn.disabled = true;
            addLog('Comenzando entrenamiento del modelo CNN 1D...');
            
            // Crear el modelo
            model = createModel();
            
            // Convertir datos a tensores y remodelar para CNN 1D
            const featuresTensor = tf.tensor2d(trainingData.features)
                .reshape([-1, ...trainingData.inputShape]);
            const labelsTensor = tf.tensor1d(trainingData.labels);
            
            // Entrenar el modelo
            await model.fit(featuresTensor, labelsTensor, {
                epochs: 30,
                batchSize: 32,
                validationSplit: 0.2,
                callbacks: {
                    onEpochEnd: (epoch, logs) => {
                        const progress = ((epoch + 1) / 30) * 100;
                        progressBar.style.width = `${progress}%`;
                        addLog(`Época ${epoch + 1}/30 - Pérdida: ${logs.loss.toFixed(4)} - Precisión: ${(logs.acc * 100).toFixed(2)}%`);
                    },
                    onTrainEnd: () => {
                        addLog('Entrenamiento completado.');
                        predictBtn.disabled = false;
                    }
                }
            });
            
            // Evaluar el modelo
            const evalResult = model.evaluate(featuresTensor, labelsTensor);
            const accuracyValue = await evalResult[1].data();
            accuracy.textContent = `${(accuracyValue[0] * 100).toFixed(1)}%`;
            
            addLog(`Precisión final del modelo: ${(accuracyValue[0] * 100).toFixed(2)}%`);
            
            // Liberar tensores de memoria
            featuresTensor.dispose();
            labelsTensor.dispose();
            evalResult[0].dispose();
            evalResult[1].dispose();
        }
        
        async function predictFrauds() {
            predictBtn.disabled = true;
            resultsContainer.innerHTML = '<p>Realizando predicciones...</p>';
            
            // Convertir datos a tensores y remodelar para CNN 1D
            const featuresTensor = tf.tensor2d(trainingData.features)
                .reshape([-1, ...trainingData.inputShape]);
            
            // Realizar predicciones
            const predictions = model.predict(featuresTensor);
            const predictionValues = await predictions.data();
            
            // Procesar resultados
            resultsContainer.innerHTML = '';
            let fraudCount = 0;
            let correctPredictions = 0;
            
            for (let i = 0; i < parsedData.length; i++) {
                const row = parsedData[i];
                const prediction = predictionValues[i];
                const isFraud = prediction > 0.5;
                const actualLabel = row.Type === 'Bot' ? 1 : 0;
                const isCorrect = (isFraud && actualLabel === 1) || (!isFraud && actualLabel === 0);
                
                if (isFraud) fraudCount++;
                if (isCorrect) correctPredictions++;
                
                const resultItem = document.createElement('div');
                resultItem.className = `result-item ${isFraud ? 'fraud' : 'legit'}`;
                
                resultItem.innerHTML = `
                    <strong>Actor ${row.Actor}</strong> - 
                    Probabilidad de fraude: ${(prediction * 100).toFixed(2)}% - 
                    <strong>${isFraud ? 'POSIBLE FRAUDE' : 'Legítimo'}</strong>
                    ${row.Type ? ` (Etiqueta real: ${row.Type})` : ''}
                    ${isCorrect ? ' ✓' : ' ✗'}
                `;
                
                resultsContainer.appendChild(resultItem);
            }
            
            // Actualizar estadísticas
            accuracy.textContent = `${(correctPredictions / parsedData.length * 100).toFixed(1)}%`;
            
            addLog(`Predicciones completadas. Se detectaron ${fraudCount} posibles fraudes.`);
            addLog(`Precisión en predicciones: ${(correctPredictions / parsedData.length * 100).toFixed(2)}%`);
            
            // Liberar tensores de memoria
            featuresTensor.dispose();
            predictions.dispose();
        }
        
        function addLog(message) {
            const logEntry = document.createElement('div');
            logEntry.className = 'log-entry';
            logEntry.textContent = message;
            trainingLog.appendChild(logEntry);
            trainingLog.scrollTop = trainingLog.scrollHeight;
        }
        
        // Mensaje inicial
        addLog('Sistema de detección de fraudes con CNN 1D listo. Cargue un archivo CSV para comenzar.');
    </script>
</body>
</html>
